
#include <stdio.h>
#include <time.h>
#include <stdint.h>
#include <stdlib.h>
#define delta 0x9E37 /*σταθερα για να αποφυγουμε την συμμετρία των γύρων */

void encrypt(uint16_t v[2],const uint16_t k[4]){ 
/*για την κρυποτγραφηση θα χρησιμοπιήσουμε δύο παράμετρους στην συνάρτησή μας
Αρχικά , με την βοήθεια του αλγορίθμου ΤΕΑ ,το αρχικό μήνυμα θα πρέπει να 
χωριστεί σε δύο μικρότερα τμήματα για να συνεχίσουμε την διαδικασία 
τησ κωδικοποίησης.Έτσι ,με την δημιουργία του πίνακα αυτού,αποθηκεύουμε
τα δύο τμήματα που θα χωρσίσουμε το αρχικό μας μήνυμα.
Η δεύτερη παράμετρος,είναι ο πίνακας που θα αποθηκεύσουμε τα τέσσερα 
κλεδιά που θα προκύπτουν με την χρήση του αλγορίθμου TEA.*/


   uint16_t v0=v[0],v1=v[1] ,sum =0,i;
    
   uint16_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];
   const int round=4;
   for(i=0 ;i<round;i++){
      sum+=delta;
      v0+= ((v1<<4) + k0) ^(v1>>5)+k1;
      v1+= ((v0<<4) + k2) ^ (v0+sum) ^ ((v0>>5) + k3);
}
    v[0]=v0;
    v[1]=v1;
}
/*Στον παρακάτω κώδικα φτιάχνω μία συνάρτηση με το όνομα 
decrypt ,η οποία θα δέχεται ως παραμέτρους το αρχικό κείμενο σαν πίνακα που θα χωριστεί σε δύο ίσα μέρη
και αντίστοιχα για το κλειδί ,το οποίο θα χωριστεί σε τέσσερα ίσα μέρη.
Ο πίνακας v[2] ,είναι ένας πίνακς ακεραίων ο οποίος  περιέχει τα δεδομένα
που θα αποδεσμευτούν.*/
void decrypt(uint16_t v[2] ,const uint16_t k[4]){

   /*Οι μεταβλητές ,v0 και v1 περιέχουν τα δύο μέρη στα οποία θα χωριστεί
το αρχικό κείμενο .Το sum θα το αρχικοποιήσουμε με την τιμή 0,είναι
μια ενδιάμεση τιμή η οποία θα χρησιμοποιηθεί για την διαδικασία της 
αποκρυπτογράφησης.*/
  uint16_t v0=v[0];
  uint16_t v1=v[1];
  uint16_t sum=0;
  uint16_t i;
/*Παρακάτω είναι οι τέσσερις τιμές που θα χωριστεί το κλειδί*/
  uint16_t  k0=k[0],k1=k[1],k2=k[2],k3=k[3];
  const int round=4;
/*Οι γύροι θα είναι τέσσερις όπως στην
εκφώνηση της άσκησης*/

/*Εκτελώ έναν βρόχο επανάληψης ,όσο είναι ο αριθμός των γύρων
και κάθε φορά  ενημερώνω τις μεταβλητές v0 και v1 απο μία σειρά με 
λειτουργίες οι οποίες έχουν μεταθέσεις και bitwise Xor.*/
/*Το sum κάθε φορά μειώνεται με την κατά την τιμή delta */

 for(i=0;i<round;i++){
    v0-=((v1<<4)+k0)^(v1>>5)+k1;
    v1-=((v0<<4)+ k2) ^ (v0+sum) ^((v0>>5) +k3);
    sum-=delta;
}
   v[0]=v0;
   v[1]=v1;
}
/*αποθηκεύονται μετά την ολοκλήρωση των γύρων στις μεταβλητές v0 και v1 
οι καινούργιες τιμές */

/*Με την συνάρτηση αυτή απαντάμε στο δεύτερο υποερώτημα της πρώτης ερώτησης 
και βρίσκουμε όπως και το όνομα της συνάρτησης  τα καινούργια κλειδιά που
δημιουργούνται*/
/*Η συνάρτηση δέχεται ως παράμετρο την τιμή του κλειδιού*/
/*Αρχικοποιεί την μεταβλητή subkey με την τιμή της πρώτης θέσης του πίνακα*/
/*Στην συνέχεια εκτελεί ένα βρόχο επανάληψης   όσα είναι τα rounds 
και εκτυπώνει την τιμή του round Που έγινε και αντίστοιχα την τιμή του κλειδιού 
με  αριστερή ολίσθηση κατά δύο θέσεις .Και τα δύο ψηφία που έφυγαν από την αρχή 
προστίθονται στο τέλος με την βοήθεια της δεξιάς ολίσθησης κατα 14*/
 void find_keys(uint16_t *key){
     uint16_t subkey=key[0];
    printf("Subkeys:\n");
    for(int i=0;i<4;i++){
         printf("Round %d:%04x\n",i+1,subkey);
         subkey=(subkey<<2) | (subkey>>14);
}
}
/*Στην συνάρτηση θα απαντήσουμε στο πρώτο υποερώτημα της πρώτης ερώτησης
,όπου έχω φτιάξει την πρώτη συνάρτηση με όνομα create_m_c
η οποία δεν δέχεται καμία παράμετρο και δημιουργεί τα αρχεία txt.
Τα κλειδία ,με βάση την εκφώνηση θα έχουν μηδενικές τιμές και θα έχουμε 
την μεταβλητή M που θα αποθηκέυσουμε το μήνυμα*/
void create_m_c(){

    uint16_t m;
    uint16_t k[4]={0,0,0,0};
    FILE*fptr;
   fptr= fopen("create_m_c.txt","w");
 if(fptr==NULL){
     printf("Could not open the file!!!");
    return ;
}else{

  /*Με τον βρόχο επανάληψης , τρέχει για 256 επαναλήψεις
και κάθε φορά η τιμή του m αποθηκεύεται στον πινακα  v[2] ως το πρώτο
στοιχείο ,καλείται η συνάρτηση encyrpt για να κρυπτογραφήσει το ζεύγος τιμών.
*/
  for(m=0;m<256;m++){
/*Κάθε φορά που η τιμή αλλάζει ,κρυπτογραφώ το ζεύγος m,0 
σηριμοποιώντας το κλειδί k.Το αποτέλεσμα αππθηκεύεται στο αρχείο .txt*/
   uint16_t v[2]={m,0}; 
      encrypt(v,k);
/*Κάθε φορά ,καταγράφεται η τιμή του m σε δεκαεξαδική τιμή με 8 ψηφία, μέσα στο αρχείο.*/
      fprintf(fptr,"M=0x%08X C=0x%08X%08X\n",m,v[0],v[1]);

}}
/*κλείνουμε το αρχείο*/
fclose(fptr);

}
 
/*Με την συνάρτηση αυτή,θα φτιάξουμε το δεύτερο αρχείο .txt
Ο στόχος είναι να κρυπτογραφήσει διαφορετικές τιμές του κλειδιού kval*/
void create_k_c(){
/*Δηλώνουμε έναν  πίνακα με τιμές μηδενικές.
Η μεταβλητή k δεν θα χρησιμοποιηθεί κατυεθίαν γιατί το κλειδί
είναι πίνακας */
  uint16_t m[2]={0,0};
  uint16_t k;
   FILE*file;
   file=fopen("create_k_c.txt","w");
     if(file==NULL){
       printf("Could not open the file!!!");
   
}else{
/*Δημιουργούμε το αρχείο και κάνουμε έλεγχο εάν θα μπορεί 
να ανοίξει το αρχείο μας.
Στον βρόχο επανάληψης  τρέχει για όλες τις τιμές της kval από 0-255*/
     for(uint16_t kval=0;kval<256;kval++){
/*Για κάθε επανάληψη που γίνεται ,ο πίνακας 
θα αρχικοποιείται με την τιμή του Kval και στις άλλες δύο τιμές
θα είναι μηδέν.
Στην συνέχεια θα καλεί την συνάρτηση για την κρυπτογράφηση και θα 
εκτυπώνει αντίστοιχα σε δεκαεξαδική μορφή με 8 ψηφία τις τιμές */
          uint16_t k[4]={kval,0,0,0};
          uint16_t v[2]={m[0],m[1]};
           encrypt(v,k);
           fprintf(file,"K=0x%08X C=0x%08X%08X \n",kval,v[0],v[1]);
}}
    fclose(file);
}
/*κλείνει το αρχείο*/


/*Με τις παρακατω συναρτήσεις υπολογίζω τον χρόνο της κρυπτογράφησης και
αποκρυπτογράφησης*/
/*Αρχικοποιούμε τον τυχαίο αριθμό και έτσι θα εξασφαλίζεται
ότι κάθε εκτέλεση  παράγει διαφορετικές τυχαίες τιμές. 

.Αρχικά ,θα φτιάξουμε έναν πίνακα με όνομα key και θα τον αρχικοποιήσουμε
με την τιμή που μας δίνετε και θα την αποθηκεύσουμε στην πρώτη θέση τοθ
πίνακα .
Στην συνέχεια ,δεσμεύουμε δυναμικά μνήμη για  έναν πίνακα δισδιάστατων 
στοιχείων  32 bit.

*/
void clock_encrypt(size_t data_size){
   srand(time(NULL));
   uint16_t key[4]={0xa1e9,0,0,0};
   uint16_t(*data)[2]= malloc(data_size*sizeof(uint16_t[2]));
/*Κάνουμε έλεγχο για εάν η δέσμευση απέτυχε και έαν ναι,τότε εμφανίζουμε
μήνυμα και πειστρέφουμε την συνάρτηση και δεν υπολογίζετε ο 
χρόνος.*/
   if(!data){
      printf("Memory allocation failed!!!\n");
      return ;
}
/*Γεμίζουμε τον πίνακα με τα δεδομένα με τυχαία δεδομένα 
και αποθηκεύονται στισ δύο θέσεις του πίνακα.*/
 for(size_t i=0;i<data_size;i++){
    data[i][0]=rand();
    data[i][1]=rand();
}
/*Ξεκινάει με την εντολή αυτή η μέτρηση του χρόονου*/
clock_t start = clock();
/* Κάνουμε ένα βρόχο επανάληψης για να κρυποτγραφήσουμε τα
δεδομένα που θα έχουν αποθηκευτεί στον πίνακα δεδομένων με την βοήθεια
του πίνακα Key.*/
for(size_t i=0;i<data_size ;i++){
    encrypt(data[i],key);
}
/*Τελειώνει ο χρόνος*/
clock_t end = clock();
/*Υπολογίζουμε τον χρόνο που χρειάστηκε για να γίνει η 
κρυπτογράφηση.*/
double time_encrypt_taken=((double)(end-start))/CLOCKS_PER_SEC;
printf("Κρυπτογράφηση: %f seconds\n",time_encrypt_taken);
/*Εκτυπώνουμε τον χρόνο και αποδεσμεύουμε την μνήμη.*/

free(data);
}


//Αποκρυπτογράφηση
/*Αρχικοποιούμε πάλι όπως και στην προηγούμενη συνάρτηση
τον πίνακα με τα κλειδιά και δεσμεύουμε δυναμικά την μνήμη .*/
void clock_decrypt(size_t data_size){
    uint16_t key[4]={0xa1e9,0,0,0};
   uint16_t(*data)[2] = malloc(data_size*sizeof(uint16_t[2]));
/*Ελέγχουμε για την δέσμευση μνήμης έαν μπορεί να γίνει.*/
  if(!data){
    printf("Memory allocation failed!!!\n");
   return ;
}/*Γεμίζουμε τον πίνακα δεδομένων με τυχαίους αριθμούς.*/
  for(size_t i=0;i<data_size;i++){
    data[i][0]=rand();
    data[i][1]=rand();
}
/*Ξεκινάει το ρολόι*/
  clock_t start=clock();
/*Καλούμε την συνάρτηση της αποκρυπτογράφησης για να αποκρυπτογραφήσουμε
το μήνυμα με την βοήθεια του κλειδιού key.*/
 for(size_t i=0;i<data_size;i++){
     decrypt(data[i],key);
}
/*Τελειώνει ο χρόνος*/
  clock_t end=clock();
/*Υπολογίζουμε τον χρόνο που θα κάνει η αποκρυπτογράφησή μας ,τον εκτυπώνουμε
και αποδεσμεύουμε την μνήμη.*/
  double time_decrypt_taken=((double )(end-start))/CLOCKS_PER_SEC;
  printf("Αποκρυπτογράφηση: %f seconds\n",time_decrypt_taken);
    
    free(data);
}


//LAT
/*Με την παρακάτω συνάρτηση ,μετράμε τον αριθμό των 1 στη δυαδική αναπαράσταση του x.
Επιστρέφει 0 εάν ο αριθμός είναι άρτιος ,διαφορετικά επιστρέφει ένα εάν είναι περιττος.
Γίνεται επανάληψη μέχρι το χ να γίνει 0.Προσθέτει το τελευταιο bit του x στον count .
Επιστρέφει 0 για άρτιο αριθμό 1και 1 για περιττό.*/
int check_odd_even(uint8_t x){
       int count =0;
      while(x){
            count+=x&1;
            x>>=1;
       }
        return count%2;
}

/*Υπολογίζουμε με την παρακάτω συνάρτηση τον πίνακα LAT.Αυτή δημιουργεί τον πίνακα γραμμικών 
προσεγγίσεων για το S box που μας δίνεται .
Αρχικοποιεί τον πίνακα LAT με 0,για κάθε ζεύγος α και β κάνει επαναλήψεις.
Για κάθε πιθανή τιμή x,εφαρμόζει την μάσκα εισόδου και μετά την μάσκα εξόδου.
Εάν η παραλληλία εισόδου και εξόδου είναι ίση αυξάνει την θέση στον πίνακα LAT.*/
void find_LAT(uint8_t Sbox[16],int LAT[16][16]){


   for(int a=0;a<16;a++){
      for(int b=0;b<16;b++){
          for(int x=0;x<16;x++){
                   int  input_num= check_odd_even(x & a);
                   int  output_num= check_odd_even(b & Sbox[x]);
                   if(input_num==output_num){
                        LAT[a][b]++;
                    }
            }
         }

       }
    printf("\nΟ πίνακας γραμμικών προσεγγίσεων (LAT):\n");
     for(int i=0;i<16;i++){
          for(int j=0;j<16;j++){
                  printf("%3d",LAT[i][j]-8);//Αφαιρείται το 8 ώστε οι τιμές στον πίνακα να είναι
//απο [-8,8] γύρω από το 0.

            }

           printf("\n");
}


}

//DDT
/*Συνάρτηση για τη δημιουργία του Πίνακα Κατανομής Διαφορών .
Αρχικοποιούμε τον πίνακα με μηδέν.
Στην συνέχεια υπολογίζουμε το DDT.*/
void find_DDT(uint8_t Sbox[16],int DDT[16][16]){

//Βρόχος για όλες τις διαφορές εισόδου.
      for(int dx=0;dx<16;dx++){
//Βρόχος για όλες τις πιθανές τιμές εισόδου.
            for(int x=0;x<16;x++){
                   int x1=x;//Αρχική τιμή
                  int x2=x^dx;//παραγωγή x2
                 int dy = Sbox[x1] ^ Sbox[x2];//Υπολογίζει την διαφορά εξόδου.
               //αυξάνεται ο πίνακας κατα μία θέση
                  DDT[dx][dy]++;
           }
       }
        printf("Πίνακας Κατανομής Διαφορών (DDT):\n");
        for(int i=0;i<16;i++){
             for(int j=0;j<16;j++){
                  printf("%2d",DDT[i][j]);
            }
           printf("\n");
     }
}

//2b
//Η συνάρτηση για να βρώ τα δέκα καλύτερα χαρακτηριστικά 
void find_best_characteristic_LAT(int LAT[16][16]){
             //Σε αυτόν τον πίνακα θα αποθηκεύσουμε τις δέκα καλύτερες τιμές για την διαφορά εισόδου dx,
//την διαφορά εξόδου dy και την πιθανότητα.
             //int best_ddt[10][3]={0};
            int best_lat[10][3]={0};
        
           for(int a=0;a<16;a++){
                for(int b=0;b<16;b++){
/*Δηλώνω την μεταβλητή prob και την αρχικοποιώ με τις τιμές του πίνακα LAT αλλά με απόλυτο καθώς υπάρχουν 
και αρνητικές ,επειδή το εύρος τιμών είναι από -8 μέχρι 8.
Στην συνέχεια ελέγχουμε εάν το κάθε στοιχείο του πίνακα είναι μεγαλύτερο από τον πίνακα best_lat,
θέλουμε να βρούμε τις μεγαλύτερες τιμές,στην συνέχεια μετακινούμε τα μικρότερα χαρακτηριστικά απο το τέλος 
στην αρχή γιατί με τον τρόπο αυτό δεν θα χαθούν τα δεδομένα μας.
Αποθηκεύουμε τις τιμες τις τελευταιες στον πίνακα best_lat και σταμάτάμε την διαδικασία με την εντολή break.*/
                            int prob=abs(LAT[a][b]);
                    for(int i=0;i<10;i++){
                          if(prob>best_lat[i][2]){
                                for(int j=9;j>i;j--){
                                        best_lat[j][0]=best_lat[j-1][0];
                                        best_lat[j][1]=best_lat[j-1][1];
                                        best_lat[j][2]=best_lat[j-1][2];
                                 }
                                   best_lat[i][0]=a;
                                   best_lat[i][1]=b;
                                   best_lat[i][2]=prob;
                                    break;
                    }
             }
       }
}
         printf("\nΤα κάλύτερα χαρακτηριστικά LAT:\n");
         for(int i=0;i<10;i++){
                printf("%2d %2d %2d\n",best_lat[i][0],best_lat[i][1],best_lat[i][2]);
}
}
void find_best_characteristic_DDT(int DDT[16][16]){
//printf("υπολογιζεται ο πινακας\n");
//DDT*/
   int best_ddt[10][3]={0};
/*Όπως και παραπάνω έτσι και εδώ κανουμε την ίδια διαδικασία απλά έχουμε την διαφορά εισόδου και εξόδου αντί
για την μάσκα εισόδου και εξόδου στον πίνακα LAT.*/
      for(int dx=0;dx<16;dx++){
            for(int dy=0;dy<16;dy++){
                    int prob=DDT[dx][dy];
                         for(int i=0;i<10;i++){
                               if(prob>best_ddt[i][2]){
                                      //Μετακίνηση των μικρότερων χαρακτηριστικών
//από το τέλος στην αρχή ώστε να μην χαθεί κάποιο δεδομένο.
                                       for(int j=9;j>i;j--){
                                               best_ddt[j][0]=best_ddt[j-1][0];
                                               best_ddt[j][1]=best_ddt[j-1][1];
                                               best_ddt[j][2]=best_ddt[j-1][2];

                                        }
                                       best_ddt[i][0]=dx;
                                       best_ddt[i][1]=dy;
                                       best_ddt[i][2]=prob;
                                        break;
                                 }
                          }
                }
        }
/*
Εκτυπώνω τα δέκα καλύτερα χαρακτηριστικά*/

printf("Tα δέκα καλύτερα χαρακτηριστικά :\n");
 for(int i=0;i<10;i++){
          printf("\n%2d %2d %2d\n",best_ddt[i][0],best_ddt[i][1],best_ddt[i][2]);
}
}

int main(){
/*Αρχικοποιούμε τον πίνακα με τα κλειδία με την αρχική τιμή που μας δίνεται 
απο την εκφώνηση και οι άλλες τιμές είναι μηδενικές και θα τις βρούμε μέσω 
της συνάρτησης find_keys.Στην μεταβλητή data θα αποθηκεύσουμε τις τιμές για
το κείμενο.Στην συνέχεια εκτυπώνουμε τις τιμές για το αρχικό κείμενο το
κρυπτογραφημένο ,καλούμε τις συναρτήσεις για να δημιουργήσουμε δύο αρχεία .txt
και να βρούμε τις τιμές των κλειδιών*/ 
     uint16_t key[4]={0xa1e9,0,0,0};
     uint16_t  data[2]={0,0};

     uint8_t Sbox[16]={0x6,0x4,0xC,0x5,0x0,0x7,0x2,0xE,
                       0x1,0xF,0x3,0xD,0x8,0xA,0x9,0xB
                       };
    int  DDT[16][16]={0};
   int  LAT[16][16]={0};
     
      
    printf("Plaintext:508x %08x\n",data[0],data[1]);
    encrypt(data,key);
    printf("Ciphertext:%08x %08x\n",data[0],data[1]);
   decrypt(data,key);
   printf("Decrypted:%08x %08x\n",data[0],data[1]);

   create_m_c();
   create_k_c();
   find_keys(key);
/*Μετράμε την ταχύτητα της αποκρυπτογράφησης και της κρυπτογράφησης για 1GiB 
δεδομένων.*/
   size_t data_size=(1<<30)/sizeof(uint16_t[2]);
//Καλούμε τις συναρτήσεις για τον υπολογισμό του χρόνου.
   clock_encrypt(data_size);
   clock_decrypt(data_size);

   
  find_LAT(Sbox,LAT);
  find_best_characteristic_LAT(LAT);
   find_DDT(Sbox,DDT);
   find_best_characteristic_DDT(DDT);
   
  
  
 return 0;
}
