
#include <stdio.h>
#include <time.h>
#include <stdint.h>
#include <stdlib.h>
#define delta 0x9E37 /*Constant to avoid the symmetry of the rounds */

void encrypt(uint16_t v[2],const uint16_t k[4]){ 
/*For encryption, we will use two parameters in our function.

Initially, with the help of the TEA algorithm, the original message must be divided into two smaller parts to proceed with the encoding process. Thus, by creating this array, we store the two parts into which we will split our original message.

The second parameter is the array where we will store the four keys generated by using the TEA algorithm.*/


   uint16_t v0=v[0],v1=v[1] ,sum =0,i;
    
   uint16_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];
   const int round=4;
   for(i=0 ;i<round;i++){
      sum+=delta;
      v0+= ((v1<<4) + k0) ^(v1>>5)+k1;
      v1+= ((v0<<4) + k2) ^ (v0+sum) ^ ((v0>>5) + k3);
}
    v[0]=v0;
    v[1]=v1;
}
/*In the following code, I create a function named decrypt, which will take as parameters the original text as an array that will be split into two equal parts, and similarly for the key, which will be split into four equal parts.

The array v[2] is an integer array that contains the data to be decrypted.
*/
void decrypt(uint16_t v[2] ,const uint16_t k[4]){

   /*The variables v0 and v1 contain the two parts into which the original text will be split. The sum variable will be initialized with the value 0; it is an intermediate value that will 
   be used in the decryption process.*/
  uint16_t v0=v[0];
  uint16_t v1=v[1];
  uint16_t sum=0;
  uint16_t i;
/*Below are the four values into which the key will be split.*/
  uint16_t  k0=k[0],k1=k[1],k2=k[2],k3=k[3];
  const int round=4;
/*The rounds will be four, as specified in the exercise description.*/

/*I execute a loop that runs for the number of rounds, and in each iteration, I update the variables v0 and v1 through a series of operations involving permutations and bitwise XOR.

/* The sum is decreased each time by the value of delta. */

 for(i=0;i<round;i++){
    v0-=((v1<<4)+k0)^(v1>>5)+k1;
    v1-=((v0<<4)+ k2) ^ (v0+sum) ^((v0>>5) +k3);
    sum-=delta;
}
   v[0]=v0;
   v[1]=v1;
}
/*After the completion of the rounds, the new values are stored in the variables v0 and v1. */

/*With this function, we address the second sub-question of the first question and, as the function's name suggests, we find the new keys that are generated.

 The function takes the key value as a parameter. 

 It initializes the subkey variable with the value of the first position of the array. /

Then, it executes a loop for as many rounds as specified, printing the round number that was performed and the corresponding key value with a left shift by two positions. The two digits that were shifted out from the beginning
 are added to the end using a right shift by 14. */
 void find_keys(uint16_t *key){
     uint16_t subkey=key[0];
    printf("Subkeys:\n");
    for(int i=0;i<4;i++){
         printf("Round %d:%04x\n",i+1,subkey);
         subkey=(subkey<<2) | (subkey>>14);
}
}
/*In the function, we will address the first sub-question of the first question, where I have created the first function named create_m_c, which takes no parameters and creates the txt files.

The keys, based on the exercise description, will have zero values, 
and we will have the variable M to store the message.*/
void create_m_c(){

    uint16_t m;
    uint16_t k[4]={0,0,0,0};
    FILE*fptr;
   fptr= fopen("create_m_c.txt","w");
 if(fptr==NULL){
     printf("Could not open the file!!!");
    return ;
}else{

  /*With the loop, it runs for 256 iterations, and each time the value of m is stored in the array v[2] as the first element. The encrypt function is called to encrypt the pair of values.
*/
  for(m=0;m<256;m++){
/*Each time the value changes, I encrypt the pair m,0, serializing the key k. The result is stored in the .txt file.*/
   uint16_t v[2]={m,0}; 
      encrypt(v,k);
/*Each time, the value of m is recorded in the file as a hexadecimal value with 8 digits..*/
      fprintf(fptr,"M=0x%08X C=0x%08X%08X\n",m,v[0],v[1]);

}}
/*close file*/
fclose(fptr);

}
 
/*With this function, we will create the second .txt file.

The goal is to encrypt different values of the key kval.*/
void create_k_c(){
/*We declare an array with zero values.

The variable k will not be used directly because the key is an array. */
  uint16_t m[2]={0,0};
  uint16_t k;
   FILE*file;
   file=fopen("create_k_c.txt","w");
     if(file==NULL){
       printf("Could not open the file!!!");
   
}else{
/*We create the file and check if our file can be opened.

In the loop, it runs for all values of kval from 0 to 255.*/
     for(uint16_t kval=0;kval<256;kval++){
/*For each iteration, the array will be initialized with the value of kval, and the other two values will be zero.

Then, it will call the encryption function and print the corresponding values in hexadecimal format with 8 digits. */
          uint16_t k[4]={kval,0,0,0};
          uint16_t v[2]={m[0],m[1]};
           encrypt(v,k);
           fprintf(file,"K=0x%08X C=0x%08X%08X \n",kval,v[0],v[1]);
}}
    fclose(file);
}
/*close file*/


/*With the following functions, I calculate the time for encryption and decryption.

We initialize the random number, ensuring that each execution produces different random values.

First, we will create an array named key and initialize it with the given value, storing it in the first position of the array.

Then, we dynamically allocate memory for a two-dimensional array of 32-bit elements.

*/
void clock_encrypt(size_t data_size){
   srand(time(NULL));
   uint16_t key[4]={0xa1e9,0,0,0};
   uint16_t(*data)[2]= malloc(data_size*sizeof(uint16_t[2]));
/*We check if the memory allocation failed, and if so, we display a message, return from the function, and the time is not calculated..*/
   if(!data){
      printf("Memory allocation failed!!!\n");
      return ;
}
/*We fill the array with random data, which are stored in the two positions of the array.*/
 for(size_t i=0;i<data_size;i++){
    data[i][0]=rand();
    data[i][1]=rand();
}
/*This command start the measurement of time*/
clock_t start = clock();
/* We are using a loop to encrypt the data that has been stored in the data table with the help of the Key table.*/
for(size_t i=0;i<data_size ;i++){
    encrypt(data[i],key);
}
/*Time ends*/
clock_t end = clock();
/*We are calculating the time it took for the encryption to happen*/
double time_encrypt_taken=((double)(end-start))/CLOCKS_PER_SEC;
printf("Encryption: %f seconds\n",time_encrypt_taken);
/*We are printing the time and releasing the memory*/

free(data);
}


//Decryption
/*We are initializing the key table again, just like in the previous function, and we are dynamically allocating memory.*/
void clock_decrypt(size_t data_size){
    uint16_t key[4]={0xa1e9,0,0,0};
   uint16_t(*data)[2] = malloc(data_size*sizeof(uint16_t[2]));
/*We are checking if the memory allocation can be done.*/
  if(!data){
    printf("Memory allocation failed!!!\n");
   return ;
}/*filling the data table with random numbers.*/
  for(size_t i=0;i<data_size;i++){
    data[i][0]=rand();
    data[i][1]=rand();
}
/*Time starts*/
  clock_t start=clock();
/*calling the decryption function to decrypt the message using the key.*/
 for(size_t i=0;i<data_size;i++){
     decrypt(data[i],key);
}
/*time ends*/
  clock_t end=clock();
/*We are calculating the time it will take for our decryption, we are printing it, and we are releasing the memory.*/
  double time_decrypt_taken=((double )(end-start))/CLOCKS_PER_SEC;
  printf("Decryption: %f seconds\n",time_decrypt_taken);
    
    free(data);
}


//LAT
/*Ah, a function to check the parity of a number by counting the set bits in its binary representation! That's a clever approach. Let's break down the English translation and then explore the logic a bit.

The English translation of your description is:

"With the following function, we count the number of 1s in the binary representation of x. It returns 0 if the number is even, otherwise it returns 1 if it is odd. The loop continues until x becomes 0. It adds the last bit of x to the count. 
It returns 0 for an even number of 1s and 1 for an odd number of 1s*/
int check_odd_even(uint8_t x){
       int count =0;
      while(x){
            count+=x&1;
            x>>=1;
       }
        return count%2;
}

/*With the following function, we calculate the LAT table. This creates the table of linear approximations for the given S-box. It initializes the LAT table with 0s. For each pair of α and β, it iterates through all possible values of x. For each possible value of x, it applies the input mask α and then the output mask β. If the input and output parity are equal, it increments the corresponding entry in the LAT table */
void find_LAT(uint8_t Sbox[16],int LAT[16][16]){


   for(int a=0;a<16;a++){
      for(int b=0;b<16;b++){
          for(int x=0;x<16;x++){
                   int  input_num= check_odd_even(x & a);
                   int  output_num= check_odd_even(b & Sbox[x]);
                   if(input_num==output_num){
                        LAT[a][b]++;
                    }
            }
         }

       }
    printf("\n (LAT):\n");
     for(int i=0;i<16;i++){
          for(int j=0;j<16;j++){
                  printf("%3d",LAT[i][j]-8);//8 is subtracted so that the values in the table are //from [-8, 8] around 0

            }

           printf("\n");
}


}

//DDT
/*Function for creating the Difference Distribution Table. We initialize the table with zeros. Then we calculate the DDT.*/
void find_DDT(uint8_t Sbox[16],int DDT[16][16]){

//Loop for all input differences.
      for(int dx=0;dx<16;dx++){
//Loop for all possible input values.
            for(int x=0;x<16;x++){
                   int x1=x;//initial value
                  int x2=x^dx;//x2
                 int dy = Sbox[x1] ^ Sbox[x2];//Calculates the output difference. 
                 //the table is incremented by one position
                  DDT[dx][dy]++;
           }
       }
        printf(" (DDT):\n");
        for(int i=0;i<16;i++){
             for(int j=0;j<16;j++){
                  printf("%2d",DDT[i][j]);
            }
           printf("\n");
     }
}

//2b
//Function of the ten best characteristics 
void find_best_characteristic_LAT(int LAT[16][16]){
             //In this array, you will store the ten best values for the input difference dx, the output difference dy, and the probability
             
            int best_lat[10][3]={0};
        
           for(int a=0;a<16;a++){
                for(int b=0;b<16;b++){
/*declare the variable prob and initialize it with the absolute values from the LAT table, as there are also negative values, because the range of values is from -8 to 8. Then, we check if each element of the prob table is greater than the best_lat table. We want to find the largest values. After that, we move the smaller characteristics from the end to the beginning because this way our data will not be lost. We store the last values in the best_lat table and stop the process with the break command.*/
                            int prob=abs(LAT[a][b]);
                    for(int i=0;i<10;i++){
                          if(prob>best_lat[i][2]){
                                for(int j=9;j>i;j--){
                                        best_lat[j][0]=best_lat[j-1][0];
                                        best_lat[j][1]=best_lat[j-1][1];
                                        best_lat[j][2]=best_lat[j-1][2];
                                 }
                                   best_lat[i][0]=a;
                                   best_lat[i][1]=b;
                                   best_lat[i][2]=prob;
                                    break;
                    }
             }
       }
}
         printf("\nBest characteristics LAT:\n");
         for(int i=0;i<10;i++){
                printf("%2d %2d %2d\n",best_lat[i][0],best_lat[i][1],best_lat[i][2]);
}
}
void find_best_characteristic_DDT(int DDT[16][16]){

//DDT*/
   int best_ddt[10][3]={0};
/*Just like above, we follow the same process here, except we use the input and output difference instead of the input and output mask as in the LAT table.*/
      for(int dx=0;dx<16;dx++){
            for(int dy=0;dy<16;dy++){
                    int prob=DDT[dx][dy];
                         for(int i=0;i<10;i++){
                               if(prob>best_ddt[i][2]){
                                      //Shift the smaller characteristics from the end to the beginning so that no data is lost
                                       for(int j=9;j>i;j--){
                                               best_ddt[j][0]=best_ddt[j-1][0];
                                               best_ddt[j][1]=best_ddt[j-1][1];
                                               best_ddt[j][2]=best_ddt[j-1][2];

                                        }
                                       best_ddt[i][0]=dx;
                                       best_ddt[i][1]=dy;
                                       best_ddt[i][2]=prob;
                                        break;
                                 }
                          }
                }
        }
/*
print the best characteristics*/

printf("Ten best Characteristics :\n");
 for(int i=0;i<10;i++){
          printf("\n%2d %2d %2d\n",best_ddt[i][0],best_ddt[i][1],best_ddt[i][2]);
}
}

int main(){
/*We initialize the key array with the initial value given in the exercise statement, while the other values are set to zero and will be found using the find_keys function. In the data variable, we will store the values for the text.
 Then, we print the values for the plaintext, the ciphertext, and call the functions to create two .txt files and to find the key values*/ 
     uint16_t key[4]={0xa1e9,0,0,0};
     uint16_t  data[2]={0,0};

     uint8_t Sbox[16]={0x6,0x4,0xC,0x5,0x0,0x7,0x2,0xE,
                       0x1,0xF,0x3,0xD,0x8,0xA,0x9,0xB
                       };
    int  DDT[16][16]={0};
   int  LAT[16][16]={0};
     
      
    printf("Plaintext:508x %08x\n",data[0],data[1]);
    encrypt(data,key);
    printf("Ciphertext:%08x %08x\n",data[0],data[1]);
   decrypt(data,key);
   printf("Decrypted:%08x %08x\n",data[0],data[1]);

   create_m_c();
   create_k_c();
   find_keys(key);
/*We measure the speed of decryption and encryption for 1GiB of data.*/
   size_t data_size=(1<<30)/sizeof(uint16_t[2]);
//We call the functions to measure the execution time..
   clock_encrypt(data_size);
   clock_decrypt(data_size);

   
  find_LAT(Sbox,LAT);
  find_best_characteristic_LAT(LAT);
   find_DDT(Sbox,DDT);
   find_best_characteristic_DDT(DDT);
   
  
  
 return 0;
}
